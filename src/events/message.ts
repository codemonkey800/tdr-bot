import { Message } from 'discord.js'
import _ from 'lodash'
import {
  formatDate,
  getClientID,
  getErrorMessage,
  getSearchResultSnippets,
} from 'src/utils'
import dayjs, { ManipulateType } from 'dayjs'

import { EventHandler } from './types'
import { ChatCompletionFunctions, Configuration, OpenAIApi } from 'openai'
import { getModule } from 'src/modules'
import { RecurrenceRule, cancelJob, scheduleJob } from 'node-schedule'

const GPT_MODEL = 'gpt-4'

async function handleWarMessage(message: Message<boolean>) {
  const clientId = getClientID()

  if (
    message.content.toLowerCase().split(' ').includes('war') &&
    message.author.id !== clientId
  ) {
    if (_.random(1, 420) === 420) {
      await message.reply('war never changes')
    }

    await message.reply('war')
    return true
  }

  return false
}

async function handleChatMessage(message: Message<boolean>) {
  const clientId = getClientID()
  const serverState = getModule('state')

  if (
    // Is own message
    message.author.id === clientId ||
    // Is not mentioned in message
    !message.mentions.users.has(clientId)
  ) {
    return false
  }

  await message.channel.sendTyping()
  let sendTypingCount = 1
  const typingInterval = setInterval(async () => {
    if (sendTypingCount > 5) {
      await message.reply(
        "Sorry it's taking me longer than usual to process this message",
      )
      clearInterval(typingInterval)

      return
    }

    sendTypingCount += 1
    await message.channel.sendTyping()
  }, 11 * 1000)

  try {
    const formattedMessage = message.mentions.users.reduce(
      (msg, user) => msg.replaceAll(`<@${user.id}>`, user.username),
      message.content,
    )

    console.log(`Generating completion for message: "${formattedMessage}"`)

    serverState.userIdMap = new Map(
      message.mentions.users.map((user) => [user.id, user.username]),
    )

    serverState.addMessage({
      role: 'user',
      content: `${message.author.id} said "${message.content}"`,
    })

    const config = new Configuration({ apiKey: process.env.OPENAI_API_KEY })
    const openai = new OpenAIApi(config)
    const functions: ChatCompletionFunctions[] = [
      {
        name: 'search',
        description: 'Requests search results from Google Search API',
        parameters: {
          properties: {
            query: {
              description: 'Query string to pass to Google search API',
              type: 'string',
            },
          },
          required: ['query'],
          type: 'object',
        },
      },

      {
        name: 'listReminders',
        description: 'List reminders for a specific user.',
        parameters: {
          properties: {},
          type: 'object',
        },
      },

      {
        name: 'removeReminder',
        description: 'Remove a specific reminder by ID.',
        parameters: {
          properties: {
            id: {
              description: 'ID to remove',
              type: 'string',
            },
          },
          required: ['id'],
          type: 'object',
        },
      },

      {
        name: 'setReminder',
        description: [
          'Set reminders to remind a specific user about something they wanted to be reminded about',
          'Do not ask for an ID, this will be generated by you.',
          'A date rule or recurrence rule must be created based on user input.',
          'There can only be `dateRule` or `recurrenceRule`, not both. Specify an empty string for the one that is not used.',
        ].join('. '),
        parameters: {
          properties: {
            id: {
              description:
                'ID to give to reminder, in format `remind-<user>-<index>`',
              type: 'string',
            },

            creator: {
              description: 'Discord user ID of reminder creator',
              type: 'string',
            },

            user: {
              description:
                'Discord user ID of the user to remind. This is set to the creator by default.',
              type: 'string',
            },

            details: {
              description:
                'Information related to what the user wanted to be reminded about.',
              type: 'string',
            },

            dateRule: {
              description: [
                'Date rule used to schedule once-occurring reminders.',
                'The value of the parameter should be a stringified JSON object with keys for `seconds`, `minutes`, `hours`, `days`, and `years`.',
                'Each value of the JSON object should be a positive number.',
              ].join('\n'),
              type: 'string',
            },

            recurrenceRule: {
              description: [
                'Recurrence rule used to schedule recurring reminders. The value of the parameter should be a cron job string.',
                // 'The value of the parameter should be a stringified JSON object in the same format as follows',
                // JSON.stringify({
                //   second: 'number (0-59)',
                //   minute: 'number (0-59)',
                //   hour: 'number (0-23)',
                //   date: 'number (1-31)',
                //   month: 'number (1-31)',
                //   year: 'number',
                //   dayOfWeek: 'number (0-6)',
                // }),
                // 'The key is the name of the key to use, and the value is the type and any min / max values',
                // 'The min / max values only apply for recurrence rules',
                // 'Each property is optional and day of the week starts on Sunday',
              ].join('\n'),
              type: 'string',
            },
          },
          required: [
            'id',
            'creator',
            'user',
            'details',
            'dateRule',
            'recurrenceRule',
          ],
          type: 'object',
        },
      },
    ]

    const response = await openai.createChatCompletion({
      functions,
      model: GPT_MODEL,
      messages: serverState.history,
    })

    console.log(
      `Received choices for author=${message.author.username}`,
      response.data.choices,
    )

    const messageResponse = response.data.choices[0].message
    if (messageResponse) {
      serverState.addMessage(messageResponse)

      if (messageResponse.function_call) {
        console.log(
          'calling function',
          JSON.stringify(messageResponse.function_call, null, 2),
        )
      }

      if (messageResponse.function_call?.name === 'search') {
        const args = JSON.parse(messageResponse.function_call.arguments ?? '{}')
        console.log(`searching on google with query: "${args.query}"`)
        const snippets = await getSearchResultSnippets(args.query)

        if (snippets) {
          serverState.addMessage({
            role: 'function',
            name: 'search',
            content: snippets,
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        } else {
          console.log(
            `Unable to load knowledge graph for query="${args.query}"`,
          )

          serverState.addMessage({
            role: 'system',
            content:
              'You were unable to find results for the previous query. Let the user know that you could not find information about it.',
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        }
      } else if (messageResponse.function_call?.name === 'listReminders') {
        const allReminders = Array.from(serverState.reminders.entries()).map(
          ([id, reminder]) => ({
            id,
            details: reminder.details,
            creator: reminder.creator,
            user: reminder.user,
            reminderDate:
              reminder.date ?? formatDate(reminder.job.nextInvocation()),
          }),
        )

        console.log('Listing all reminders', allReminders)

        serverState.addMessage({
          role: 'system',
          content:
            allReminders.length === 0
              ? 'Let user know there are no reminders.'
              : [
                  'List the reminders in a list in a nicely formatted way. Format the date to be human readable in AM / PM PST',
                  'The following is a JSON array containing an object that has the reminder ID, details, and next reminder date',
                  'If the creator and user are different, indicate that the reminder was created by the creator and is for the user',
                  JSON.stringify(allReminders),
                ].join('. '),
        })

        const nextResponse = await openai.createChatCompletion({
          functions,
          model: GPT_MODEL,
          messages: serverState.history,
        })

        const nextMessageResponse = nextResponse.data.choices[0].message
        if (nextMessageResponse) {
          await message.channel.send(nextMessageResponse)
        }
      } else if (messageResponse.function_call?.name === 'cancelReminder') {
        const args = JSON.parse(messageResponse.function_call.arguments ?? '{}')
        console.log(`removing reminder with id: ${args.id}`)

        const reminder = serverState.reminders.get(args.id)
        if (reminder) {
          serverState.reminders.delete(args.id)
          cancelJob(reminder.job)
          console.log(`Cancelled job with id: ${args.id}`)

          serverState.addMessage({
            role: 'system',
            content: 'You were able to cancel the reminder, let the user know.',
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        } else {
          console.log(`Unable to find job for id="${args.id}`)

          serverState.addMessage({
            role: 'system',
            content:
              'You were not able to cancel the reminder, let the user know.',
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        }
      } else if (messageResponse.function_call?.name === 'setReminder') {
        const args = JSON.parse(messageResponse.function_call.arguments ?? '{}')

        console.log(
          `creating new${
            args.dateRule ? ' ' : ' recurring '
          }reminder with id: ${args.id}`,
        )

        if (args.dateRule || args.recurrenceRule) {
          // const rrule = new RecurrenceRule()
          // rrule.tz = 'America/Los_Angeles'

          // if (args.recurrenceRule) {
          //   Object.entries(JSON.parse(args.recurrenceRule)).forEach(
          //     ([key, value]) => _.set(rrule, key, value),
          //   )
          // }

          let date = dayjs()
          if (args.dateRule) {
            Object.entries(JSON.parse(args.dateRule)).forEach(
              ([key, value]) => {
                date = date.add(value as number, key as ManipulateType)
              },
            )
          }

          const creator = message.author.id
          const rule = args.dateRule ? date.toDate() : args.recurrenceRule
          const job = scheduleJob(args.id, rule, async () => {
            console.log(
              `Sending reminder id=${args.id} details=${args.details} creator=${args.creator} user=${args.user}`,
            )

            serverState.addMessage({
              role: 'system',
              content: [
                `The reminder ${args.id} has been triggered.`,
                `Tell the target user ${args.user} that ${args.creator} about the reminder.`,
                'Focus on just describing the details of the reminder rather than the reminder itself.',
                'Use the following details to describe the reminder:',
                args.details,
              ].join('\n'),
            })

            const nextResponse = await openai.createChatCompletion({
              functions,
              model: GPT_MODEL,
              messages: serverState.history,
            })

            const nextMessageResponse = nextResponse.data.choices[0].message
            if (nextMessageResponse) {
              await message.channel.send(nextMessageResponse)
            }

            if (args.dateRule) {
              serverState.reminders.delete(args.id)
            }
          })

          serverState.reminders.set(args.id, {
            job,
            creator,
            user: args.user,
            details: args.details,
            date: args.dateRule ? formatDate(date) : undefined,
          })

          serverState.addMessage({
            role: 'system',
            content: `Let user know a ${
              args.dateRule ? 'once-occurring' : 'recurring'
            } reminder that should happen on ${
              args.dateRule ? formatDate(date) : job.nextInvocation().toString()
            }. Show the exact date`,
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        } else {
          serverState.addMessage({
            role: 'system',
            content:
              'You were unable to create a reminder because you could not figure out the date or recurrence rule.',
          })

          const nextResponse = await openai.createChatCompletion({
            functions,
            model: GPT_MODEL,
            messages: serverState.history,
          })

          const nextMessageResponse = nextResponse.data.choices[0].message
          if (nextMessageResponse) {
            await message.channel.send(nextMessageResponse)
          }
        }
      } else {
        await message.channel.send(messageResponse)
      }
    } else {
      throw new Error('Chat completion could not be generated :(')
    }
    clearInterval(typingInterval)
    console.log('Response sent successfully')
  } catch (err) {
    serverState.messages.pop()

    console.error('Error resolving chat message', err)

    await message.reply(
      `An error occurred for this message\n\`\`\`\n${getErrorMessage(
        err,
      )}\n\`\`\`\nTry clearing the chat history on https://tdr-bot.fly.dev/history\nCheck the logs at https://fly.io/apps/tdr-bot/monitoring`,
    )

    clearInterval(typingInterval)

    return false
  }

  return true
}

async function handleProgMessage(message: Message<boolean>) {
  const clientId = getClientID()

  if (
    message.content.toLowerCase().split(' ').includes('prog') &&
    message.author.id !== clientId
  ) {
    await message.reply('prog')
    return true
  }

  return false
}

const handlers = [handleWarMessage, handleProgMessage, handleChatMessage]

export const messageHandler: EventHandler<'messageCreate'> = {
  event: 'messageCreate',

  async handler(message) {
    for (const handler of handlers) {
      // eslint-disable-next-line no-await-in-loop
      if (await handler(message)) {
        return
      }
    }
  },
}
